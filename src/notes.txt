The res.json and res.send methods in Express are used to send responses to the client, but they have some differences:

res.json:

Automatically sets the Content-Type header to application/json.
Converts the JavaScript object or array passed to it into a JSON string.
Useful for sending JSON responses.
Example:
res.json({ firstName: 'Snehlata', lastName: 'Prajapti' });

res.send:

Can send various types of responses, including strings, buffers, and objects.
Automatically sets the Content-Type header based on the type of the response body.
If an object or array is passed, it behaves similarly to res.json by converting it to a JSON string.
Example:res.send("hello from the test");


what is json respons
A JSON response is a response from a server that is formatted as JSON (JavaScript Object Notation).
JSON is a lightweight data interchange format that is easy for humans to read and write and easy
for machines to parse and generate. It is commonly used for transmitting data in web applications.
In the context of an Express.js application, a JSON response is typically sent using the res.json
method. This method converts a JavaScript object or array into a JSON string and sets the Content-Type 
header to application/json.

Here is an example of a JSON response in your Express.js application:
app.get('/user', (req, res) => {
    res.json({ firstName: 'Snehlata', lastName: 'Prajapti' });
});
When a client makes a GET request to the /user endpoint, the server responds with the following JSON data:
{
    "firstName": "Snehlata",
    "lastName": "Prajapti"
}

This JSON response can be easily consumed by client-side applications, such as web browsers or mobile apps, 
and used to display data or perform other actions.

**use, get, head, post, patch, delete, options, listen explain all**

1. app.use()
Purpose: Middleware function that is executed for every incoming request to the specified path or globally if no path is provided.
Example:
app.use("/test", (req, res) => {
    res.send("hello from the test");
});
Explanation: This middleware is triggered for any request to /test and sends a response with the message "hello from the test".

2. app.get()
Purpose: Handles HTTP GET requests, typically used to retrieve data.
Example:
app.get('/user', (req, res) => {
    res.json({ firstName: 'Snehlata', lastName: 'Prajapti' });
});
Explanation: This route responds to GET requests to /user by sending a JSON object with user details.

3. app.head()
Purpose: Handles HTTP HEAD requests, which are similar to GET but do not return a response body, only headers.
Example:
app.head('/user', (req, res) => {
    res.status(200).end();
});
Explanation: This route responds to HEAD requests to /user with a status code of 200 and no body.

4. app.post()
Purpose: Handles HTTP POST requests, typically used to create new resources.
Example:
app.post('/user', (req, res) => {
    res.json({ message: 'User created' });
});
Explanation: This route responds to POST requests to /user by sending a JSON message indicating that a user has been created.

5. app.put()
Purpose: Handles HTTP PUT requests, typically used to update or replace an existing resource or create it if it does not exist.
Example:
app.put('/user', (req, res) => {
    const user = req.body;
    res.json({ message: 'User Updated or created', user });
});
Explanation: This route responds to PUT requests to /user by updating or creating a user with the data provided in the request body.

6. app.patch()
Purpose: Handles HTTP PATCH requests, typically used to apply partial updates to a resource.
Example:
app.patch('/user', (req, res) => {
    const updates = req.body;
    res.json({ message: 'User Updated', updates });
});
Explanation: This route responds to PATCH requests to /user by applying the updates provided in the request body.

7. app.delete()
Purpose: Handles HTTP DELETE requests, typically used to delete a resource.
Example:
app.delete('/user', (req, res) => {
    res.json({ message: 'User deleted' });
});
Explanation: This route responds to DELETE requests to /user by sending a JSON message indicating that the user has been deleted.

8. app.options()
Purpose: Handles HTTP OPTIONS requests, typically used to describe the communication options for a resource.
Example:
app.options('/user', (req, res) => {
    res.set('Allow', 'GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD');
    res.sendStatus(200);
});
Explanation: This route responds to OPTIONS requests to /user by sending an Allow header that lists the supported HTTP methods.

9. app.listen()
Purpose: Starts the Express server and listens for incoming requests on a specified port.
Example:
app.listen(1300, () => {
    console.log('Server is running on port 1300');
});
Explanation: This starts the server on port 1300 and logs a message to the console indicating that the server is running.


**what is middleware, routes and rautes handler**

#1. Middleware
Definition: Middleware functions are functions that execute during the lifecycle of a request to the server. They have access to the request (req) and response (res) objects and can modify them or terminate the request-response cycle.
Purpose:
Perform tasks like logging, authentication, parsing request bodies, etc.
Pass control to the next middleware or route handler using next().
Example:
const express = require('express');
const app = express();

// Middleware to log requests
app.use((req, res, next) => {
    console.log(`${req.method} request to ${req.url}`);
    next(); // Pass control to the next middleware or route
});

app.get('/user', (req, res) => {
    res.json({ firstName: 'Snehlata', lastName: 'Prajapti' });
});

app.listen(1300, () => {
    console.log('Server is running on port 1300');
});
Key Points:
Middleware can be global (applies to all routes) or specific to certain routes.
Common middleware includes express.json() (to parse JSON bodies) and express.static() (to serve static files).


#2. Routes
Definition: Routes define the endpoints (URLs) of your application and specify how the server should respond to client requests.
Purpose:
Organize your application by defining specific paths and HTTP methods (e.g., GET, POST, PUT, etc.).
Example:
app.get('/user', (req, res) => {
    res.json({ firstName: 'Snehlata', lastName: 'Prajapti' });
});

app.post('/user', (req, res) => {
    res.json({ message: 'User created' });
});

Key Points:
Routes are defined using HTTP methods like GET, POST, PUT, DELETE, etc.
Each route specifies a path (e.g., /user) and a handler function.


#3. Route Handlers
Definition: A route handler is the function that executes when a specific route is matched. It processes the request and sends a response.
Purpose:
Handle the logic for a specific route, such as fetching data, processing input, or sending a response.
Example:
app.get('/user', (req, res) => {
    res.json({ firstName: 'Snehlata', lastName: 'Prajapti' });
});
In this example, the route handler sends a JSON response when a GET request is made to /user.
Key Points:
A route can have multiple handlers (middleware functions) that execute in sequence.
Handlers can perform tasks like validating input, querying a database, or formatting a response.

#How They Work Together
Middleware: Executes first and performs tasks like logging, authentication, or parsing request data.
Routes: Match the incoming request's URL and HTTP method.
Route Handlers: Execute the logic for the matched route and send a response.

//**lecture-2.5